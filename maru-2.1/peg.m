(define-selector $equals)
(define-selector $blank)
(define-selector $eol)
(define-selector $comment)
(define-selector $space)
(define-selector $bar)
(define-selector $pling)
(define-selector $ampersand)
(define-selector $colon)
(define-selector $arrow)
(define-selector $quotesgl)
(define-selector $backquote)
(define-selector $commaat)
(define-selector $comma)
(define-selector $dollarhash)
(define-selector $dollardbl)
(define-selector $dollar)
(define-selector $at)
(define-selector $query)
(define-selector $minus)
(define-selector $plus)
(define-selector $star)
(define-selector $lparen)
(define-selector $rparen)
(define-selector $lbrace)
(define-selector $rbrace)
(define-selector $dot)
(define-selector $digit)
(define-selector $higit)
(define-selector $number)
(define-selector $letter)
(define-selector $idpart)
(define-selector $identifier)
(define-selector $char)
(define-selector $string)
(define-selector $class)
(define-selector $grammar)
(define-selector $symfirst)
(define-selector $symrest)
(define-selector $symbol)
(define-selector $sexpr)
(define-selector $scomment)
(define-selector $sspace)
(define-selector $sexpression)
(define-selector $llist)
(define-selector $atom)
(define-selector $repetition)
(define-selector $conversion)
(define-selector $predicate)
(define-selector $sequence)
(define-selector $expression)
(define-selector $definition)
(define-selector $start)
(define-selector $gen_cola)
(define-selector $gen_cola_value_declarations)
(define-selector $gen_cola_effect_declarations)
(define-selector $gen_cola_value_declaration)
(define-selector $gen_cola_effect_declaration)
(define-selector $gen_cola_value_definitions)
(define-selector $gen_cola_effect_definitions)
(define-selector $gen_cola_value_definition)
(define-selector $gen_cola_effect_definition)
(define-selector $findvars)
(define-selector $value)
(define-selector $effect)
(define-selector $$equals)
(define-selector $$blank)
(define-selector $$eol)
(define-selector $$comment)
(define-selector $$space)
(define-selector $$bar)
(define-selector $$pling)
(define-selector $$ampersand)
(define-selector $$colon)
(define-selector $$arrow)
(define-selector $$quotesgl)
(define-selector $$backquote)
(define-selector $$commaat)
(define-selector $$comma)
(define-selector $$dollarhash)
(define-selector $$dollardbl)
(define-selector $$dollar)
(define-selector $$at)
(define-selector $$query)
(define-selector $$minus)
(define-selector $$plus)
(define-selector $$star)
(define-selector $$lparen)
(define-selector $$rparen)
(define-selector $$lbrace)
(define-selector $$rbrace)
(define-selector $$dot)
(define-selector $$digit)
(define-selector $$higit)
(define-selector $$number)
(define-selector $$letter)
(define-selector $$idpart)
(define-selector $$identifier)
(define-selector $$char)
(define-selector $$string)
(define-selector $$class)
(define-selector $$grammar)
(define-selector $$symfirst)
(define-selector $$symrest)
(define-selector $$symbol)
(define-selector $$sexpr)
(define-selector $$scomment)
(define-selector $$sspace)
(define-selector $$sexpression)
(define-selector $$llist)
(define-selector $$atom)
(define-selector $$repetition)
(define-selector $$conversion)
(define-selector $$predicate)
(define-selector $$sequence)
(define-selector $$expression)
(define-selector $$definition)
(define-selector $$start)
(define-selector $$gen_cola)
(define-selector $$gen_cola_value_declarations)
(define-selector $$gen_cola_effect_declarations)
(define-selector $$gen_cola_value_declaration)
(define-selector $$gen_cola_effect_declaration)
(define-selector $$gen_cola_value_definitions)
(define-selector $$gen_cola_effect_definitions)
(define-selector $$gen_cola_value_definition)
(define-selector $$gen_cola_effect_definition)
(define-selector $$findvars)
(define-selector $$value)
(define-selector $$effect)
(define-method $equals <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "=") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $blank <peg> () (let () (set self.result (parser-stream-match-class self.source "\011 "))))
(define-method $eol <peg> () (let () (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "\012") (let ((_list_ (group))) (while (set self.result (parser-stream-match-string self.source "\015")) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "\015") (let ((_list_ (group))) (while (set self.result (parser-stream-match-string self.source "\012")) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))))))
(define-method $comment <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "#") (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and ($$eol self) (set (<parser-stream>-position self.source) pos)))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $space <peg> () (let () (let ((_list_ (group))) (while (or ($blank self) ($eol self) ($comment self)) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)))
(define-method $bar <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "|") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $pling <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "!") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $ampersand <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "&") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $colon <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ":") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $arrow <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "->") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $quotesgl <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "'") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $backquote <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "`") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $commaat <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ",@") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $comma <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ",") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $dollarhash <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "$#") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $dollardbl <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "$$") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $dollar <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "$") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $at <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "@") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $query <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "?") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $minus <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "-") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $plus <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "+") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $star <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "*") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $lparen <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "(") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $rparen <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ")") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $lbrace <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "{") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $rbrace <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "}") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $dot <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ".") ($space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $digit <peg> () (let () (set self.result (parser-stream-match-class self.source "0123456789"))))
(define-method $higit <peg> () (let () (set self.result (parser-stream-match-class self.source "0123456789ABCDEFabcdef"))))
(define-method $number <peg> () (let ((n)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (let ((pos (<parser-stream>-position self.source))) (and (let ((pos (<parser-stream>-position self.source))) (or (and (let () (parser-stream-match-string self.source "-") 1) (and ($$digit self) (let () (while ($$digit self)) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result (list-from-to pos (<parser-stream>-position self.source))) 1))) (set self.result (string->number-base (list->string self.result) 10))) (let () (set n self.result) 1)) ($$space self) (let () (set self.result n) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $letter <peg> () (let () (set self.result (parser-stream-match-class self.source "ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"))))
(define-method $idpart <peg> () (let () (and (let ((pos (<parser-stream>-position self.source))) (and (let ((pos (<parser-stream>-position self.source))) (or (and ($$letter self) (let () (while (or ($$letter self) ($$digit self))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result (list-from-to pos (<parser-stream>-position self.source))) 1))) (set self.result (string->symbol (list->string self.result))))))
(define-method $identifier <peg> () (let ((id)) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($idpart self) (let () (set id self.result) 1)) ($$space self) (let () (set self.result id) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $char <peg> () (let () (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "\\") (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "t") (let () (set self.result 9) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "n") (let () (set self.result 10) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "r") (let () (set self.result 13) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "x") (and (let ((pos (<parser-stream>-position self.source))) (and (let ((pos (<parser-stream>-position self.source))) (or (and ($$higit self) ($$higit self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result (list-from-to pos (<parser-stream>-position self.source))) 1))) (set self.result (string->number-base (list->string self.result) 16)))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "u") (and (let ((pos (<parser-stream>-position self.source))) (and (let ((pos (<parser-stream>-position self.source))) (or (and ($$higit self) ($$higit self) ($$higit self) ($$higit self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result (list-from-to pos (<parser-stream>-position self.source))) 1))) (set self.result (string->number-base (list->string self.result) 16)))) (let () (set (<parser-stream>-position self.source) pos) ()))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (let () (set (<parser-stream>-position self.source) pos) ()))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))))
(define-method $string <peg> () (let ((s)) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "\"") (and (and (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and (parser-stream-match-string self.source "\"") (set (<parser-stream>-position self.source) pos)))) ($char self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))) (let () (set s self.result) 1)) (parser-stream-match-string self.source "\"") ($$space self) (let () (set self.result s) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $class <peg> () (let ((s)) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "[") (and (and (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and (parser-stream-match-string self.source "]") (set (<parser-stream>-position self.source) pos)))) ($char self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))) (let () (set s self.result) 1)) (parser-stream-match-string self.source "]") ($$space self) (let () (set self.result s) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $grammar <peg> () (let ((e) (d) (fields) (parent) (rules) (name)) (or (let ((pos (<parser-stream>-position self.source))) (or (and (and ($symbol self) (let () (set name self.result) 1)) ($$space self) ($$plus self) (and (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set rules self.result) 1)) ($$space self) (let () (set self.result (quasiquote (grammar-extend (unquote name) (unquote-splicing rules)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($symbol self) (let () (set name self.result) 1)) ($$space self) ($$colon self) (and ($symbol self) (let () (set parent self.result) 1)) ($$space self) (let () (let ((pos (<parser-stream>-position self.source))) (or (and ($$lparen self) (and (let ((_list_ (group))) (while ($identifier self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set fields self.result) 1)) ($$rparen self)) (let () (set (<parser-stream>-position self.source) pos) ()))) 1) (and (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set rules self.result) 1)) ($$space self) (let () (set self.result (quasiquote (grammar-define (unquote name) (unquote parent) (unquote fields) (unquote-splicing rules)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set d self.result) 1)) ($$space self) (and (let ((_list_ (group))) (and ($expression self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set e self.result) 1)) (let () (set self.result (quasiquote (grammar-eval (unquote d) (unquote (car e))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))))))
(define-method $symfirst <peg> () (let () (set self.result (parser-stream-match-class self.source "!#$%&*+-/:<=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz|~"))))
(define-method $symrest <peg> () (let () (set self.result (parser-stream-match-class self.source "!#$%&*+-./0123456789:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz|~"))))
(define-method $symbol <peg> () (let () (and (let ((pos (<parser-stream>-position self.source))) (and (let ((pos (<parser-stream>-position self.source))) (or (and ($$symfirst self) (let () (while ($$symrest self)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result (list-from-to pos (<parser-stream>-position self.source))) 1))) (set self.result (string->symbol (list->string self.result))))))
(define-method $sexpr <peg> () (let ((f) (e)) (or (and (let ((pos (<parser-stream>-position self.source))) (and (let ((pos (<parser-stream>-position self.source))) (or (and (let () (parser-stream-match-string self.source "-") 1) (and ($$digit self) (let () (while ($$digit self)) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result (list-from-to pos (<parser-stream>-position self.source))) 1))) (set self.result (string->number-base (list->string self.result) 10))) ($symbol self) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "?") (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "\"") (and (and (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and (parser-stream-match-string self.source "\"") (set (<parser-stream>-position self.source) pos)))) ($char self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))) (let () (set e self.result) 1)) (parser-stream-match-string self.source "\"") (let () (set self.result e) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "(") (and (let ((_list_ (group))) (while ($sexpression self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set e self.result) 1)) (let () (let ((pos (<parser-stream>-position self.source))) (or (and ($$space self) ($$dot self) (and ($sexpression self) (let () (set f self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) 1) ($$sspace self) (parser-stream-match-string self.source ")") (let () (set self.result (set-list-source (quasiquote ((unquote-splicing e) (unquote-splicing f))) e)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "'") (and ($sexpression self) (let () (set e self.result) 1)) (let () (set self.result (list (quote quote) e)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "`") (and ($sexpression self) (let () (set e self.result) 1)) (let () (set self.result (list (quote quasiquote) e)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ",@") (and ($sexpression self) (let () (set e self.result) 1)) (let () (set self.result (list (quote unquote-splicing) e)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ",") (and ($sexpression self) (let () (set e self.result) 1)) (let () (set self.result (list (quote unquote) e)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "{") ($$space self) (and ($grammar self) (let () (set e self.result) 1)) (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "}") (let () (set self.result e) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result (error "error in grammar near: " (parser-stream-context self.source))) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ";") (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and (parser-stream-match-class self.source "\012\015") (set (<parser-stream>-position self.source) pos)))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))))))
(define-method $scomment <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ";") (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and ($$eol self) (set (<parser-stream>-position self.source) pos)))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $sspace <peg> () (let () (let ((_list_ (group))) (while (or ($blank self) ($eol self) ($scomment self)) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)))
(define-method $sexpression <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and ($$sspace self) ($sexpr self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $llist <peg> () (let ((e)) (let ((pos (<parser-stream>-position self.source))) (or (and ($$lparen self) (and ($expression self) (let () (set e self.result) 1)) ($$rparen self) (let () (set self.result e) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $atom <peg> () (let ((p) (e)) (or (let ((pos (<parser-stream>-position self.source))) (or (and ($$lparen self) (and ($expression self) (let () (set e self.result) 1)) ($$rparen self) (let () (set self.result e) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$quotesgl self) (and ($sexpression self) (let () (set e self.result) 1)) ($$space self) (let () (set self.result (quasiquote (match-object (unquote e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($string self) (let () (set e self.result) 1)) (let () (set self.result (quasiquote (match-string (unquote e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($class self) (let () (set e self.result) 1)) (let () (set self.result (quasiquote (match-class (unquote e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($idpart self) (let () (set p self.result) 1)) (parser-stream-match-string self.source "-") (and ($identifier self) (let () (set e self.result) 1)) (let () (set self.result (quasiquote (match-rule-in (unquote p) (unquote e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($identifier self) (let () (set e self.result) 1)) (let () (set self.result (quasiquote (match-rule (unquote e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$lbrace self) (and (let ((_list_ (group))) (while ($sexpression self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set e self.result) 1)) ($$space self) ($$rbrace self) (let () (set self.result (quasiquote (match-rule (unquote-splicing e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$dot self) (let () (set self.result (quasiquote (match-any))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$arrow self) (and ($sexpression self) (let () (set e self.result) 1)) ($$space self) (let () (set self.result (quasiquote (result-expr (unquote e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$backquote self) (and ($llist self) (let () (set e self.result) 1)) (let () (set self.result (quasiquote (match-list (unquote e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))))))
(define-method $repetition <peg> () (let ((e)) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($atom self) (let () (set e self.result) 1)) (let () (or (let ((pos (<parser-stream>-position self.source))) (or (and ($$query self) (and (let () (set self.result (quasiquote (match-zero-one (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$star self) (and (let () (set self.result (quasiquote (match-zero-more (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$plus self) (and (let () (set self.result (quasiquote (match-one-more (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ())))) 1) (let () (set self.result e) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $conversion <peg> () (let ((i) (n) (e)) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($repetition self) (let () (set e self.result) 1)) (let () (while (or (let ((pos (<parser-stream>-position self.source))) (or (and ($$at self) (and (let () (set self.result (quasiquote (make-span (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$dollarhash self) (or (let ((pos (<parser-stream>-position self.source))) (or (and (and ($number self) (let () (set n self.result) 1)) (and (let () (set self.result (quasiquote (make-number (unquote n) (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (and (let () (set self.result (quasiquote (make-number 10 (unquote e)))) 1) (let () (set e self.result) 1)))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$dollardbl self) (and (let () (set self.result (quasiquote (make-symbol (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$dollar self) (and (let () (set self.result (quasiquote (make-string (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$colon self) (and ($identifier self) (let () (set i self.result) 1)) (and (let () (set self.result (quasiquote (assign-result (unquote i) (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))))) 1) (let () (set self.result e) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $predicate <peg> () (let ((e)) (or (let ((pos (<parser-stream>-position self.source))) (or (and ($$pling self) (and ($conversion self) (let () (set e self.result) 1)) (let () (set self.result (quasiquote (peek-not (unquote e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$ampersand self) (or (let ((pos (<parser-stream>-position self.source))) (or (and ($$arrow self) (and ($sexpression self) (let () (set e self.result) 1)) ($$space self) (let () (set self.result (quasiquote (peek-expr (unquote e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($conversion self) (let () (set e self.result) 1)) (let () (set self.result (quasiquote (peek-for (unquote e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))))) (let () (set (<parser-stream>-position self.source) pos) ()))) ($conversion self))))
(define-method $sequence <peg> () (let ((q) (p)) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($predicate self) (let () (set p self.result) 1)) (or (let ((pos (<parser-stream>-position self.source))) (or (and (and (let ((_list_ (group))) (while ($predicate self) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set q self.result) 1)) (let () (set self.result (quasiquote (match-all (unquote p) (unquote-splicing q)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result p) 1))) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $expression <peg> () (let ((t) (s)) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($sequence self) (let () (set s self.result) 1)) (or (let ((pos (<parser-stream>-position self.source))) (or (and (and (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and ($$bar self) ($sequence self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set t self.result) 1)) (let () (set self.result (quasiquote (match-first (unquote s) (unquote-splicing t)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result s) 1))) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $definition <peg> () (let ((e) (id)) (let ((pos (<parser-stream>-position self.source))) (or (and ($$space self) (and ($identifier self) (let () (set id self.result) 1)) ($$equals self) (and ($expression self) (let () (set e self.result) 1)) (parser-stream-match-string self.source ";") (let () (set self.result (quasiquote ((unquote id) (unquote e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $start <peg> () (let () ($definition self)))
(define-method $gen_cola <peg> () (let ((d) (c) (b) (a)) (let ((pos (<parser-stream>-position self.source))) (or (and (let ((pos (<parser-stream>-position self.source))) (and (and ($gen_cola_value_declarations self) (let () (set a self.result) 1)) (set (<parser-stream>-position self.source) pos))) (let ((pos (<parser-stream>-position self.source))) (and (and ($gen_cola_effect_declarations self) (let () (set b self.result) 1)) (set (<parser-stream>-position self.source) pos))) (let ((pos (<parser-stream>-position self.source))) (and (and ($gen_cola_value_definitions self) (let () (set c self.result) 1)) (set (<parser-stream>-position self.source) pos))) (and ($gen_cola_effect_definitions self) (let () (set d self.result) 1)) (let () (set self.result (quasiquote ((unquote-splicing a) (unquote-splicing b) (unquote-splicing c) (unquote-splicing d)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $gen_cola_value_declarations <peg> () (let () (let ((_list_ (group))) (while ($gen_cola_value_declaration self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)))
(define-method $gen_cola_effect_declarations <peg> () (let () (let ((_list_ (group))) (while ($gen_cola_effect_declaration self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)))
(define-method $gen_cola_value_declaration <peg> () (let ((id)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set id self.result) 1)))) (set self.source src) (and ok (parser-stream-next src))))) (let () (set self.result (quasiquote (define-selector (unquote (concat-symbol (quote $) id))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $gen_cola_effect_declaration <peg> () (let ((id)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set id self.result) 1)))) (set self.source src) (and ok (parser-stream-next src))))) (let () (set self.result (quasiquote (define-selector (unquote (concat-symbol (quote $$) id))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $gen_cola_value_definitions <peg> () (let () (let ((_list_ (group))) (while ($gen_cola_value_definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)))
(define-method $gen_cola_effect_definitions <peg> () (let () (let ((_list_ (group))) (while ($gen_cola_effect_definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)))
(define-method $gen_cola_value_definition <peg> () (let ((exp) (vars) (id)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set id self.result) 1)) (let ((pos (<parser-stream>-position self.source))) (and (and (let () (parser-stream-push self.source ()) (or ($findvars self) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set vars self.result) 1)) (set (<parser-stream>-position self.source) pos))) (and ($value self) (let () (set exp self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (set self.result (quasiquote (define-method (unquote (concat-symbol (quote $) id)) <peg> () (let (unquote vars) (unquote exp))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $gen_cola_effect_definition <peg> () (let ((exp) (vars) (id)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set id self.result) 1)) (let ((pos (<parser-stream>-position self.source))) (and (and (let () (parser-stream-push self.source ()) (or ($findvars self) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set vars self.result) 1)) (set (<parser-stream>-position self.source) pos))) (and ($effect self) (let () (set exp self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (set self.result (quasiquote (define-method (unquote (concat-symbol (quote $$) id)) <peg> () (let (unquote vars) (unquote exp))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $findvars <peg> () (let ((name) (vars)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set vars self.result) 1)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote assign-result)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and (let () (parser-stream-push self.source vars) (or ($findvars self) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set vars self.result) 1)) (let () (set self.result (if (assq name vars) vars (cons (cons name) vars))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote result-expr)) (let () (set self.result vars) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-any self.source) (let () (while (and (let () (parser-stream-push self.source vars) (or ($findvars self) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set vars self.result) 1))) 1) (let () (set self.result vars) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result vars) 1)))) (set self.source src) (and ok (parser-stream-next src)))))) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $value <peg> () (let ((op) (r) (obj) (str) (exp) (v) (e) (exps) (type) (args) (name)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set args self.result) 1)) (let () (set self.result (quasiquote (let () (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (or ((unquote (concat-symbol (quote $) name)) self) (let () (set (<parser-stream>-position self.source) pos) ()))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (let () (set self.result (quasiquote ((unquote (concat-symbol (quote $) name)) self))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule-in)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set type self.result) 1)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set args self.result) 1)) (let () (set self.result (quasiquote (let ((pos (<parser-stream>-position self.source)) (_p (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source))) (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (if ((unquote (concat-symbol (quote $) name)) _p) (let () (set self.result (<parser>-result _p)) 1) (let () (set (<parser-stream>-position self.source) pos) ()))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule-in)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set type self.result) 1)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (let () (set self.result (quasiquote (let ((_p (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source))) (and ((unquote (concat-symbol (quote $) name)) _p) (let () (set self.result (<parser>-result _p)) 1))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-first)) (and (let ((_list_ (group))) (while ($value self) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set exps self.result) 1)) (let () (set self.result (quasiquote (or (unquote-splicing exps)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-all)) (and (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and (let ((pos (<parser-stream>-position self.source))) (and (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-any self.source) (parser-stream-match-any self.source)) (let () (set (<parser-stream>-position self.source) pos) ()))) (set (<parser-stream>-position self.source) pos))) ($effect self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set e self.result) 1)) (and ($value self) (let () (set v self.result) 1)) (let () (set self.result (quasiquote (let ((pos (<parser-stream>-position self.source))) (or (and (unquote-splicing e) (unquote v)) (let () (set (<parser-stream>-position self.source) pos) ()))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-zero-one)) (and ($value self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (let ((_list_ (group))) (and (unquote exp) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-zero-more)) (and ($value self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (let ((_list_ (group))) (while (unquote exp) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-one-more)) (and ($value self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (let ((_list_ (group))) (while (unquote exp) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-for)) (and ($value self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-expr)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set exp self.result) 1)) (let () (set self.result exp) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-not)) (and ($value self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (not (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos)))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-list)) (and ($value self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (unquote exp))) (set self.source src) (and ok (parser-stream-next src))))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-class)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set str self.result) 1)) (let () (set self.result (quasiquote (set self.result (parser-stream-match-class self.source (unquote (make-class str)))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-string)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set str self.result) 1)) (let () (set self.result (quasiquote (set self.result (parser-stream-match-string self.source (unquote str))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-object)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set obj self.result) 1)) (let () (set self.result (quasiquote (and (= (quote (unquote obj)) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-any)) (let () (set self.result (quote (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-span)) (and ($effect self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (let () (set self.result (list-from-to pos (<parser-stream>-position self.source))) 1))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-string)) (and ($value self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (and (unquote exp) (set self.result (list->string self.result))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-symbol)) (and ($value self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (and (unquote exp) (set self.result (string->symbol (list->string self.result)))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-number)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set r self.result) 1)) (and ($value self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (and (unquote exp) (set self.result (string->number-base (list->string self.result) (unquote r)))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote assign-result)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and ($value self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (and (unquote exp) (let () (set (unquote name) self.result) 1)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote result-expr)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (let () (set self.result (unquote exp)) 1))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set op self.result) 1)) (let () (set self.result (error "cannot generate value for " op)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result (error "cannot generate value for nil")) 1)))) (set self.source src) (and ok (parser-stream-next src)))))))
(define-method $effect <peg> () (let ((op) (r) (obj) (str) (exp) (e) (exps) (type) (args) (name)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set args self.result) 1)) (let () (set self.result (quasiquote (let () (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (or ((unquote (concat-symbol (quote $$) name)) self) (let () (set (<parser-stream>-position self.source) pos) ()))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (let () (set self.result (quasiquote ((unquote (concat-symbol (quote $$) name)) self))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule-in)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set type self.result) 1)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set args self.result) 1)) (let () (set self.result (quasiquote (let ((pos (<parser-stream>-position self.source))) (let () (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (or ((unquote (concat-symbol (quote $$) name)) (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source)) (let () (set (<parser-stream>-position self.source) pos) ())))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule-in)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set type self.result) 1)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (let () (set self.result (quasiquote ((unquote (concat-symbol (quote $$) name)) (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-first)) (and (let ((_list_ (group))) (while ($effect self) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set exps self.result) 1)) (let () (set self.result (quasiquote (or (unquote-splicing exps)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-all)) (and (let ((_list_ (group))) (while ($effect self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set e self.result) 1)) (let () (set self.result (quasiquote (let ((pos (<parser-stream>-position self.source))) (or (and (unquote-splicing e)) (let () (set (<parser-stream>-position self.source) pos) ()))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-zero-one)) (and ($effect self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (let () (unquote exp) 1))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-zero-more)) (and ($effect self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (let () (while (unquote exp)) 1))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-one-more)) (and ($effect self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (and (unquote exp) (let () (while (unquote exp)) 1)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-for)) (and ($effect self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-expr)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set exp self.result) 1)) (let () (set self.result exp) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-not)) (and ($effect self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (not (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos)))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-list)) (and ($effect self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (unquote exp))) (set self.source src) (and ok (parser-stream-next src))))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-class)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set str self.result) 1)) (let () (set self.result (quasiquote (parser-stream-match-class self.source (unquote (make-class str))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-string)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set str self.result) 1)) (let () (set self.result (quasiquote (parser-stream-match-string self.source (unquote str)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-object)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set obj self.result) 1)) (let () (set self.result (quasiquote (parser-stream-match-object self.source (quote (unquote obj))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-any)) (let () (set self.result (quote (parser-stream-match-any self.source))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-span)) (and ($effect self) (let () (set exp self.result) 1)) (let () (set self.result exp) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-string)) (and ($effect self) (let () (set exp self.result) 1)) (let () (set self.result exp) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-symbol)) (and ($effect self) (let () (set exp self.result) 1)) (let () (set self.result exp) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-number)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set r self.result) 1)) (and ($effect self) (let () (set exp self.result) 1)) (let () (set self.result exp) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote assign-result)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and ($value self) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (and (unquote exp) (let () (set (unquote name) self.result) 1)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote result-expr)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set exp self.result) 1)) (let () (set self.result (quasiquote (let () (unquote exp) 1))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set op self.result) 1)) (let () (set self.result (error "cannot generate value for " op)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result (error "cannot generate value for nil")) 1)))) (set self.source src) (and ok (parser-stream-next src)))))))
(define-method $$equals <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "=") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$blank <peg> () (let () (parser-stream-match-class self.source "\011 ")))
(define-method $$eol <peg> () (let () (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "\012") (let () (while (parser-stream-match-string self.source "\015")) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "\015") (let () (while (parser-stream-match-string self.source "\012")) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))))))
(define-method $$comment <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "#") (let () (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and ($$eol self) (set (<parser-stream>-position self.source) pos)))) (parser-stream-match-any self.source)) (let () (set (<parser-stream>-position self.source) pos) ())))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$space <peg> () (let () (let () (while (or ($$blank self) ($$eol self) ($$comment self))) 1)))
(define-method $$bar <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "|") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$pling <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "!") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$ampersand <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "&") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$colon <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ":") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$arrow <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "->") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$quotesgl <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "'") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$backquote <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "`") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$commaat <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ",@") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$comma <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ",") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$dollarhash <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "$#") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$dollardbl <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "$$") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$dollar <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "$") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$at <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "@") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$query <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "?") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$minus <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "-") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$plus <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "+") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$star <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "*") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$lparen <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "(") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$rparen <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ")") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$lbrace <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "{") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$rbrace <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "}") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$dot <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ".") ($$space self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$digit <peg> () (let () (parser-stream-match-class self.source "0123456789")))
(define-method $$higit <peg> () (let () (parser-stream-match-class self.source "0123456789ABCDEFabcdef")))
(define-method $$number <peg> () (let ((n)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (let ((pos (<parser-stream>-position self.source))) (and (let ((pos (<parser-stream>-position self.source))) (or (and (let () (parser-stream-match-string self.source "-") 1) (and ($$digit self) (let () (while ($$digit self)) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set self.result (list-from-to pos (<parser-stream>-position self.source))) 1))) (set self.result (string->number-base (list->string self.result) 10))) (let () (set n self.result) 1)) ($$space self) (let () n 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$letter <peg> () (let () (parser-stream-match-class self.source "ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz")))
(define-method $$idpart <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and ($$letter self) (let () (while (or ($$letter self) ($$digit self))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$identifier <peg> () (let ((id)) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($idpart self) (let () (set id self.result) 1)) ($$space self) (let () id 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$char <peg> () (let () (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "\\") (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "t") (let () 9 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "n") (let () 10 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "r") (let () 13 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "x") (let ((pos (<parser-stream>-position self.source))) (or (and ($$higit self) ($$higit self)) (let () (set (<parser-stream>-position self.source) pos) ())))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "u") (let ((pos (<parser-stream>-position self.source))) (or (and ($$higit self) ($$higit self) ($$higit self) ($$higit self)) (let () (set (<parser-stream>-position self.source) pos) ())))) (let () (set (<parser-stream>-position self.source) pos) ()))) (parser-stream-match-any self.source))) (let () (set (<parser-stream>-position self.source) pos) ()))) (parser-stream-match-any self.source))))
(define-method $$string <peg> () (let ((s)) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "\"") (and (and (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and (parser-stream-match-string self.source "\"") (set (<parser-stream>-position self.source) pos)))) ($char self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))) (let () (set s self.result) 1)) (parser-stream-match-string self.source "\"") ($$space self) (let () s 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$class <peg> () (let ((s)) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "[") (and (and (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and (parser-stream-match-string self.source "]") (set (<parser-stream>-position self.source) pos)))) ($char self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))) (let () (set s self.result) 1)) (parser-stream-match-string self.source "]") ($$space self) (let () s 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$grammar <peg> () (let ((e) (d) (fields) (parent) (rules) (name)) (or (let ((pos (<parser-stream>-position self.source))) (or (and (and ($symbol self) (let () (set name self.result) 1)) ($$space self) ($$plus self) (and (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set rules self.result) 1)) ($$space self) (let () (quasiquote (grammar-extend (unquote name) (unquote-splicing rules))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($symbol self) (let () (set name self.result) 1)) ($$space self) ($$colon self) (and ($symbol self) (let () (set parent self.result) 1)) ($$space self) (let () (let ((pos (<parser-stream>-position self.source))) (or (and ($$lparen self) (and (let ((_list_ (group))) (while ($identifier self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set fields self.result) 1)) ($$rparen self)) (let () (set (<parser-stream>-position self.source) pos) ()))) 1) (and (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set rules self.result) 1)) ($$space self) (let () (quasiquote (grammar-define (unquote name) (unquote parent) (unquote fields) (unquote-splicing rules))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set d self.result) 1)) ($$space self) (and (let ((_list_ (group))) (and ($expression self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set e self.result) 1)) (let () (quasiquote (grammar-eval (unquote d) (unquote (car e)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))))))
(define-method $$symfirst <peg> () (let () (parser-stream-match-class self.source "!#$%&*+-/:<=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz|~")))
(define-method $$symrest <peg> () (let () (parser-stream-match-class self.source "!#$%&*+-./0123456789:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz|~")))
(define-method $$symbol <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and ($$symfirst self) (let () (while ($$symrest self)) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$sexpr <peg> () (let ((f) (e)) (or (let ((pos (<parser-stream>-position self.source))) (or (and (let () (parser-stream-match-string self.source "-") 1) (and ($$digit self) (let () (while ($$digit self)) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) ($$symbol self) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "?") (parser-stream-match-any self.source)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "\"") (and (and (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and (parser-stream-match-string self.source "\"") (set (<parser-stream>-position self.source) pos)))) ($char self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))) (let () (set e self.result) 1)) (parser-stream-match-string self.source "\"") (let () e 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "(") (and (let ((_list_ (group))) (while ($sexpression self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set e self.result) 1)) (let () (let ((pos (<parser-stream>-position self.source))) (or (and ($$space self) ($$dot self) (and ($sexpression self) (let () (set f self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) 1) ($$sspace self) (parser-stream-match-string self.source ")") (let () (set-list-source (quasiquote ((unquote-splicing e) (unquote-splicing f))) e) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "'") (and ($sexpression self) (let () (set e self.result) 1)) (let () (list (quote quote) e) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "`") (and ($sexpression self) (let () (set e self.result) 1)) (let () (list (quote quasiquote) e) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ",@") (and ($sexpression self) (let () (set e self.result) 1)) (let () (list (quote unquote-splicing) e) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ",") (and ($sexpression self) (let () (set e self.result) 1)) (let () (list (quote unquote) e) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "{") ($$space self) (and ($grammar self) (let () (set e self.result) 1)) (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source "}") (let () e 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (error "error in grammar near: " (parser-stream-context self.source)) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ";") (let () (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and (parser-stream-match-class self.source "\012\015") (set (<parser-stream>-position self.source) pos)))) (parser-stream-match-any self.source)) (let () (set (<parser-stream>-position self.source) pos) ())))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))))))
(define-method $$scomment <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-string self.source ";") (let () (while (let ((pos (<parser-stream>-position self.source))) (or (and (not (let ((pos (<parser-stream>-position self.source))) (and ($$eol self) (set (<parser-stream>-position self.source) pos)))) (parser-stream-match-any self.source)) (let () (set (<parser-stream>-position self.source) pos) ())))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$sspace <peg> () (let () (let () (while (or ($$blank self) ($$eol self) ($$scomment self))) 1)))
(define-method $$sexpression <peg> () (let () (let ((pos (<parser-stream>-position self.source))) (or (and ($$sspace self) ($$sexpr self)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$llist <peg> () (let ((e)) (let ((pos (<parser-stream>-position self.source))) (or (and ($$lparen self) (and ($expression self) (let () (set e self.result) 1)) ($$rparen self) (let () e 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$atom <peg> () (let ((p) (e)) (or (let ((pos (<parser-stream>-position self.source))) (or (and ($$lparen self) (and ($expression self) (let () (set e self.result) 1)) ($$rparen self) (let () e 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$quotesgl self) (and ($sexpression self) (let () (set e self.result) 1)) ($$space self) (let () (quasiquote (match-object (unquote e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($string self) (let () (set e self.result) 1)) (let () (quasiquote (match-string (unquote e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($class self) (let () (set e self.result) 1)) (let () (quasiquote (match-class (unquote e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($idpart self) (let () (set p self.result) 1)) (parser-stream-match-string self.source "-") (and ($identifier self) (let () (set e self.result) 1)) (let () (quasiquote (match-rule-in (unquote p) (unquote e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($identifier self) (let () (set e self.result) 1)) (let () (quasiquote (match-rule (unquote e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$lbrace self) (and (let ((_list_ (group))) (while ($sexpression self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set e self.result) 1)) ($$space self) ($$rbrace self) (let () (quasiquote (match-rule (unquote-splicing e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$dot self) (let () (quasiquote (match-any)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$arrow self) (and ($sexpression self) (let () (set e self.result) 1)) ($$space self) (let () (quasiquote (result-expr (unquote e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$backquote self) (and ($llist self) (let () (set e self.result) 1)) (let () (quasiquote (match-list (unquote e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))))))
(define-method $$repetition <peg> () (let ((e)) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($atom self) (let () (set e self.result) 1)) (let () (or (let ((pos (<parser-stream>-position self.source))) (or (and ($$query self) (and (let () (set self.result (quasiquote (match-zero-one (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$star self) (and (let () (set self.result (quasiquote (match-zero-more (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$plus self) (and (let () (set self.result (quasiquote (match-one-more (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ())))) 1) (let () e 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$conversion <peg> () (let ((i) (n) (e)) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($repetition self) (let () (set e self.result) 1)) (let () (while (or (let ((pos (<parser-stream>-position self.source))) (or (and ($$at self) (and (let () (set self.result (quasiquote (make-span (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$dollarhash self) (or (let ((pos (<parser-stream>-position self.source))) (or (and (and ($number self) (let () (set n self.result) 1)) (and (let () (set self.result (quasiquote (make-number (unquote n) (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (and (let () (set self.result (quasiquote (make-number 10 (unquote e)))) 1) (let () (set e self.result) 1)))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$dollardbl self) (and (let () (set self.result (quasiquote (make-symbol (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$dollar self) (and (let () (set self.result (quasiquote (make-string (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$colon self) (and ($identifier self) (let () (set i self.result) 1)) (and (let () (set self.result (quasiquote (assign-result (unquote i) (unquote e)))) 1) (let () (set e self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))))) 1) (let () e 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$predicate <peg> () (let ((e)) (or (let ((pos (<parser-stream>-position self.source))) (or (and ($$pling self) (and ($conversion self) (let () (set e self.result) 1)) (let () (quasiquote (peek-not (unquote e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and ($$ampersand self) (or (let ((pos (<parser-stream>-position self.source))) (or (and ($$arrow self) (and ($sexpression self) (let () (set e self.result) 1)) ($$space self) (let () (quasiquote (peek-expr (unquote e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($conversion self) (let () (set e self.result) 1)) (let () (quasiquote (peek-for (unquote e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))))) (let () (set (<parser-stream>-position self.source) pos) ()))) ($$conversion self))))
(define-method $$sequence <peg> () (let ((q) (p)) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($predicate self) (let () (set p self.result) 1)) (or (let ((pos (<parser-stream>-position self.source))) (or (and (and (let ((_list_ (group))) (while ($predicate self) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set q self.result) 1)) (let () (quasiquote (match-all (unquote p) (unquote-splicing q))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () p 1))) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$expression <peg> () (let ((t) (s)) (let ((pos (<parser-stream>-position self.source))) (or (and (and ($sequence self) (let () (set s self.result) 1)) (or (let ((pos (<parser-stream>-position self.source))) (or (and (and (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and ($$bar self) ($sequence self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set t self.result) 1)) (let () (quasiquote (match-first (unquote s) (unquote-splicing t))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () s 1))) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$definition <peg> () (let ((e) (id)) (let ((pos (<parser-stream>-position self.source))) (or (and ($$space self) (and ($identifier self) (let () (set id self.result) 1)) ($$equals self) (and ($expression self) (let () (set e self.result) 1)) (parser-stream-match-string self.source ";") (let () (quasiquote ((unquote id) (unquote e))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$start <peg> () (let () ($$definition self)))
(define-method $$gen_cola <peg> () (let ((d) (c) (b) (a)) (let ((pos (<parser-stream>-position self.source))) (or (and (let ((pos (<parser-stream>-position self.source))) (and (and ($gen_cola_value_declarations self) (let () (set a self.result) 1)) (set (<parser-stream>-position self.source) pos))) (let ((pos (<parser-stream>-position self.source))) (and (and ($gen_cola_effect_declarations self) (let () (set b self.result) 1)) (set (<parser-stream>-position self.source) pos))) (let ((pos (<parser-stream>-position self.source))) (and (and ($gen_cola_value_definitions self) (let () (set c self.result) 1)) (set (<parser-stream>-position self.source) pos))) (and ($gen_cola_effect_definitions self) (let () (set d self.result) 1)) (let () (quasiquote ((unquote-splicing a) (unquote-splicing b) (unquote-splicing c) (unquote-splicing d))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$gen_cola_value_declarations <peg> () (let () (let () (while ($$gen_cola_value_declaration self)) 1)))
(define-method $$gen_cola_effect_declarations <peg> () (let () (let () (while ($$gen_cola_effect_declaration self)) 1)))
(define-method $$gen_cola_value_declaration <peg> () (let ((id)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set id self.result) 1)))) (set self.source src) (and ok (parser-stream-next src))))) (let () (quasiquote (define-selector (unquote (concat-symbol (quote $) id)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$gen_cola_effect_declaration <peg> () (let ((id)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set id self.result) 1)))) (set self.source src) (and ok (parser-stream-next src))))) (let () (quasiquote (define-selector (unquote (concat-symbol (quote $$) id)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$gen_cola_value_definitions <peg> () (let () (let () (while ($$gen_cola_value_definition self)) 1)))
(define-method $$gen_cola_effect_definitions <peg> () (let () (let () (while ($$gen_cola_effect_definition self)) 1)))
(define-method $$gen_cola_value_definition <peg> () (let ((exp) (vars) (id)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set id self.result) 1)) (let ((pos (<parser-stream>-position self.source))) (and (and (let () (parser-stream-push self.source ()) (or ($findvars self) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set vars self.result) 1)) (set (<parser-stream>-position self.source) pos))) (and ($value self) (let () (set exp self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (quasiquote (define-method (unquote (concat-symbol (quote $) id)) <peg> () (let (unquote vars) (unquote exp)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$gen_cola_effect_definition <peg> () (let ((exp) (vars) (id)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set id self.result) 1)) (let ((pos (<parser-stream>-position self.source))) (and (and (let () (parser-stream-push self.source ()) (or ($findvars self) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set vars self.result) 1)) (set (<parser-stream>-position self.source) pos))) (and ($effect self) (let () (set exp self.result) 1))) (let () (set (<parser-stream>-position self.source) pos) ()))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (quasiquote (define-method (unquote (concat-symbol (quote $$) id)) <peg> () (let (unquote vars) (unquote exp)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$findvars <peg> () (let ((name) (vars)) (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set vars self.result) 1)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote assign-result)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and (let () (parser-stream-push self.source vars) (or ($findvars self) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set vars self.result) 1)) (let () (if (assq name vars) vars (cons (cons name) vars)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote result-expr)) (let () vars 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-any self.source) (let () (while (and (let () (parser-stream-push self.source vars) (or ($findvars self) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (set vars self.result) 1))) 1) (let () vars 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () vars 1)))) (set self.source src) (and ok (parser-stream-next src)))))) (let () (set (<parser-stream>-position self.source) pos) ())))))
(define-method $$value <peg> () (let ((op) (r) (obj) (str) (exp) (v) (e) (exps) (type) (args) (name)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set args self.result) 1)) (let () (quasiquote (let () (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (or ((unquote (concat-symbol (quote $) name)) self) (let () (set (<parser-stream>-position self.source) pos) ())))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (let () (quasiquote ((unquote (concat-symbol (quote $) name)) self)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule-in)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set type self.result) 1)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set args self.result) 1)) (let () (quasiquote (let ((pos (<parser-stream>-position self.source)) (_p (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source))) (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (if ((unquote (concat-symbol (quote $) name)) _p) (let () (set self.result (<parser>-result _p)) 1) (let () (set (<parser-stream>-position self.source) pos) ())))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule-in)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set type self.result) 1)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (let () (quasiquote (let ((_p (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source))) (and ((unquote (concat-symbol (quote $) name)) _p) (let () (set self.result (<parser>-result _p)) 1)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-first)) (and (let ((_list_ (group))) (while ($value self) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set exps self.result) 1)) (let () (quasiquote (or (unquote-splicing exps))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-all)) (and (let ((_list_ (group))) (while (let ((pos (<parser-stream>-position self.source))) (or (and (let ((pos (<parser-stream>-position self.source))) (and (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-any self.source) (parser-stream-match-any self.source)) (let () (set (<parser-stream>-position self.source) pos) ()))) (set (<parser-stream>-position self.source) pos))) ($effect self)) (let () (set (<parser-stream>-position self.source) pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set e self.result) 1)) (and ($value self) (let () (set v self.result) 1)) (let () (quasiquote (let ((pos (<parser-stream>-position self.source))) (or (and (unquote-splicing e) (unquote v)) (let () (set (<parser-stream>-position self.source) pos) ())))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-zero-one)) (and ($value self) (let () (set exp self.result) 1)) (let () (quasiquote (let ((_list_ (group))) (and (unquote exp) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-zero-more)) (and ($value self) (let () (set exp self.result) 1)) (let () (quasiquote (let ((_list_ (group))) (while (unquote exp) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-one-more)) (and ($value self) (let () (set exp self.result) 1)) (let () (quasiquote (let ((_list_ (group))) (while (unquote exp) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-for)) (and ($value self) (let () (set exp self.result) 1)) (let () (quasiquote (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-expr)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set exp self.result) 1)) (let () exp 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-not)) (and ($value self) (let () (set exp self.result) 1)) (let () (quasiquote (not (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-list)) (and ($value self) (let () (set exp self.result) 1)) (let () (quasiquote (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (unquote exp))) (set self.source src) (and ok (parser-stream-next src)))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-class)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set str self.result) 1)) (let () (quasiquote (set self.result (parser-stream-match-class self.source (unquote (make-class str))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-string)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set str self.result) 1)) (let () (quasiquote (set self.result (parser-stream-match-string self.source (unquote str)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-object)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set obj self.result) 1)) (let () (quasiquote (and (= (quote (unquote obj)) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-any)) (let () (quote (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-span)) (and ($effect self) (let () (set exp self.result) 1)) (let () (quasiquote (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (let () (set self.result (list-from-to pos (<parser-stream>-position self.source))) 1)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-string)) (and ($value self) (let () (set exp self.result) 1)) (let () (quasiquote (and (unquote exp) (set self.result (list->string self.result)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-symbol)) (and ($value self) (let () (set exp self.result) 1)) (let () (quasiquote (and (unquote exp) (set self.result (string->symbol (list->string self.result))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-number)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set r self.result) 1)) (and ($value self) (let () (set exp self.result) 1)) (let () (quasiquote (and (unquote exp) (set self.result (string->number-base (list->string self.result) (unquote r))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote assign-result)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and ($value self) (let () (set exp self.result) 1)) (let () (quasiquote (and (unquote exp) (let () (set (unquote name) self.result) 1))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote result-expr)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set exp self.result) 1)) (let () (quasiquote (let () (set self.result (unquote exp)) 1)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set op self.result) 1)) (let () (error "cannot generate value for " op) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (error "cannot generate value for nil") 1)))) (set self.source src) (and ok (parser-stream-next src)))))))
(define-method $$effect <peg> () (let ((op) (r) (obj) (str) (exp) (e) (exps) (type) (args) (name)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set args self.result) 1)) (let () (quasiquote (let () (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (or ((unquote (concat-symbol (quote $$) name)) self) (let () (set (<parser-stream>-position self.source) pos) ())))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (let () (quasiquote ((unquote (concat-symbol (quote $$) name)) self)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule-in)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set type self.result) 1)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set args self.result) 1)) (let () (quasiquote (let ((pos (<parser-stream>-position self.source))) (let () (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (or ((unquote (concat-symbol (quote $$) name)) (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source)) (let () (set (<parser-stream>-position self.source) pos) ()))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-rule-in)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set type self.result) 1)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (let () (quasiquote ((unquote (concat-symbol (quote $$) name)) (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-first)) (and (let ((_list_ (group))) (while ($effect self) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set exps self.result) 1)) (let () (quasiquote (or (unquote-splicing exps))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-all)) (and (let ((_list_ (group))) (while ($effect self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1) (let () (set e self.result) 1)) (let () (quasiquote (let ((pos (<parser-stream>-position self.source))) (or (and (unquote-splicing e)) (let () (set (<parser-stream>-position self.source) pos) ())))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-zero-one)) (and ($effect self) (let () (set exp self.result) 1)) (let () (quasiquote (let () (unquote exp) 1)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-zero-more)) (and ($effect self) (let () (set exp self.result) 1)) (let () (quasiquote (let () (while (unquote exp)) 1)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-one-more)) (and ($effect self) (let () (set exp self.result) 1)) (let () (quasiquote (and (unquote exp) (let () (while (unquote exp)) 1))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-for)) (and ($effect self) (let () (set exp self.result) 1)) (let () (quasiquote (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-expr)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set exp self.result) 1)) (let () exp 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote peek-not)) (and ($effect self) (let () (set exp self.result) 1)) (let () (quasiquote (not (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-list)) (and ($effect self) (let () (set exp self.result) 1)) (let () (quasiquote (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (unquote exp))) (set self.source src) (and ok (parser-stream-next src)))))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-class)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set str self.result) 1)) (let () (quasiquote (parser-stream-match-class self.source (unquote (make-class str)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-string)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set str self.result) 1)) (let () (quasiquote (parser-stream-match-string self.source (unquote str))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-object)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set obj self.result) 1)) (let () (quasiquote (parser-stream-match-object self.source (quote (unquote obj)))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote match-any)) (let () (quote (parser-stream-match-any self.source)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-span)) (and ($effect self) (let () (set exp self.result) 1)) (let () exp 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-string)) (and ($effect self) (let () (set exp self.result) 1)) (let () exp 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-symbol)) (and ($effect self) (let () (set exp self.result) 1)) (let () exp 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote make-number)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set r self.result) 1)) (and ($effect self) (let () (set exp self.result) 1)) (let () exp 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote assign-result)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set name self.result) 1)) (and ($value self) (let () (set exp self.result) 1)) (let () (quasiquote (and (unquote exp) (let () (set (unquote name) self.result) 1))) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (parser-stream-match-object self.source (quote result-expr)) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set exp self.result) 1)) (let () (quasiquote (let () (unquote exp) 1)) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let ((pos (<parser-stream>-position self.source))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let () (set op self.result) 1)) (let () (error "cannot generate value for " op) 1)) (let () (set (<parser-stream>-position self.source) pos) ()))) (let () (error "cannot generate value for nil") 1)))) (set self.source src) (and ok (parser-stream-next src)))))))
